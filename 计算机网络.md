- [0、TCP/UDP 的区别](#0tcpudp-的区别)
- [1、TCP 三次握手的过程及原因](#1tcp-三次握手的过程及原因)
- [2、HTTP 请求](#2http-请求)
  - [GET](#get)
  - [POST](#post)
  - [HEAD](#head)
  - [DELETE](#delete)
- [3、在浏览器中输入 URL 地址到显示主页的过程](#3在浏览器中输入-url-地址到显示主页的过程)
- [4、HTTP 的长连接和短连接](#4http-的长连接和短连接)
- [5、OSI 七层模型](#5osi-七层模型)
- [6、应用层协议举例](#6应用层协议举例)
- [7、TCP 如何保证可靠传输](#7tcp-如何保证可靠传输)
- [8、TCP 四次挥手](#8tcp-四次挥手)
- [9、为什么有了 IP 还需要 UDP](#9为什么有了-ip-还需要-udp)
- [10、HTTP 和 HTTPS](#10http-和-https)
- [11、HTTP 版本发展历史](#11http-版本发展历史)
- [12、HTTP 响应](#12http-响应)
  - [响应报文的构成](#响应报文的构成)
- [13、Socket](#13socket)
- [14、HTTP 请求头](#14http-请求头)
  - [User-Agent](#user-agent)
  - [Cookie](#cookie)
# 0、TCP/UDP 的区别
TCP 和 UDP 都是 OSI 参考模型中的传输层协议。

TCP 面向连接，提供可靠的服务，数据传输慢；UDP 发送数据前不需要建立连接，把可靠数据传输的任务交给应用层处理，数据传输快。

TCP 面向字节流，UDP 面向报文。

# 1、TCP 三次握手的过程及原因
TCP 三次握手的目的：同步双方的序列号、交换 TCP 的窗口大小信息、确认双方的发送和接收能力。

第一次握手：客户端发送请求报文，SYN 置为 1，Seq 为 x，发送完毕后客户端进入 SYN_SEND 状态，等待服务器确认；  
第二次握手：服务器端接收到客户端的 SYN 报文段后，需要发送 SYN/ACK 报文，设置 ACK 为 x+1，SYN 置为 1，Seq 为 y，发送完毕后服务器进入 SYN_RECV 状态；  
第三次握手：客户端收到 SYN/ACK 报文，向服务器发送 ACK 报文，Seq 设为 y+1。三次握手完成后，双方进入 ESTABLISHED 状态

需要三次握手的原因：
* 建立可靠的通信信道，使得双方都能够确认双方的发送与接收能力是正常的。
  * 第一次握手：Client 什么也不能确认，Server 确认了对方能正确发送
  * 第二次握手：Client 确认自己发送、接收正常，对方发送、接受正常，Server 确认自己接受正常，对方发送正常
  * 第三次握手：双方确认双方的发送、接受正常
* 解决多次建立连接请求的混乱问题。如果只是两次握手，那么发送方一旦发出建立连接的请求之后，它就没有办法撤回该请求。在网络状况复杂或者较差的情况下，发送方连续发送多次建立连接的请求，接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是一次历史连接请求还是一次较新的连接请求。TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息。接收方当收到请求时会将发送方发来的 Seq+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：
  * 如果当前连接是历史连接，即 Seq 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接
  * 如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接

# 2、HTTP 请求
## GET
对服务器资源的请求。GET 报文中包含了请求行（包含请求方法、URL、协议/版本）和请求头，参数在 URL 中是可见的，同时 URL 会记录在服务器的日志上

## POST
提交用户数据的请求。相对于 GET 来说安全一些，因为数据不会被显示在 URL 中，同时参数也不会被保存在浏览器历史和服务器日志中，而是被包含在了报文的 body 中

## HEAD
类似于 GET 请求，只不过返回的相应中没有具体的内容，用于获取报头

## DELETE
请求服务器删除指定的页面

# 3、在浏览器中输入 URL 地址到显示主页的过程
* 浏览器查找域名的 IP 地址（浏览器缓存、路由器缓存、DNS 缓存、询问域名服务器）
* 浏览器向 Web 服务器发送一个 HTTP 请求
* 服务器处理并响应请求
* 浏览器显示 HTML 文件

# 4、HTTP 的长连接和短连接
HTTP/1.0 中默认使用短连接，客户端和服务器每进行一次 HTTP 操作就建立一次连接，任务结束就中断连接。

而从 HTTP/1.1 起，默认使用长连接，体现在响应头里加入的一段代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭。客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。keep-alive 不会永久保持连接，它有一个可以设定的保持时间

# 5、OSI 七层模型
* 应用层：网络服务与用户的接口
* 表示层：数据的表示、加密、压缩
* 会话层：对话的建立、管理
* 传输层：定义传输数据的端口号，差错控制、流量控制
* 网络层：不同网络间的路由选择
* 数据链路层：成帧，建立逻辑连接，进行硬件地址寻址、差错校验等功能
* 物理层：在物理链路上透明地传输比特流

# 6、应用层协议举例
* HTTP：超文本传输协议
* HTTPS：超文本传输安全协议
* FTP：文件传输协议
* SMTP：简单邮件传输协议
* POP3：邮局协议版本 3
* Telnet：远程登录协议

# 7、TCP 如何保证可靠传输
TCP 分组头部的校验和保证了差错控制，使用滑动窗口来实现流量控制，检测到网络拥塞时减少数据的发送来实现拥塞控制。

TCP 协议给发送的每一个包进行编号，在滑动窗口的基础上，采用捎带应答、超时重传、丢弃重复分组的方式来保证传输的可靠性。

# 8、TCP 四次挥手
* (1) 客户端发送 FIN 报文请求释放连接，进入 FIN_WAIT1 状态
* (2) 服务器发送 ACK 报文，进入 CLOSED_WAIT 状态。此 ACK 报文被客户端收到后，客户端进入 FIN_WAIT2 状态
* (3) 服务器处理完数据后，也向客户端发送 FIN 报文
* (4) 客户端回复 ACK 报文

TCP 握手可以只有三次，因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文（捎带应答）。

TCP 断开连接需要四次挥手，是因为当 Server 端收到 FIN 报文时很可能正在传输数据或者仍然有数据要传输，所以只能先回复一个 ACK 报文。只有等到 Server 端所有的报文都发送完了，才能主动发送 FIN 报文。

# 9、为什么有了 IP 还需要 UDP
还需要 UDP 指定端口号来完成进程之间的网络通信。UDP 指定端口号范围为 0 ~ 65535

# 10、HTTP 和 HTTPS
HTTPS = HTTP + SSL(安全套接层)/TLS(安全传输层协议)

当 HTTP 页面包含一些数据传输时，会被浏览器标记为不安全。使用 HTTP 协议时，例如客户端对服务器发送一个登录的请求，账号和密码都会明文显示在 URL 中，很容易被截获利用

当使用 HTTPS 时，传输数据的流程：
* 首先客户端通过 URL 访问服务器建立 SSL 连接
* 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
* 客户端和服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级
* 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
* 服务器利用自己的私钥解密出会话密钥
* 服务器利用会话密钥加密与客户端之间的通信

当然，HTTPS 会导致加载的延时以及服务器 CPU 资源的消耗

HTTP 的默认端口是 80，HTTPS 是 443

# 11、HTTP 版本发展历史
|  版本   |  时间  | 内容 |
|  :----:  | :----: | :----:|
| HTTP/0.9 | 1991 | 只有 GET 请求 |
| HTTP/1.0 | 1996 | 传输内容不受限制，增加了 PUT、HEAD、OPTIONS、DELETE 等 |
| HTTP/1.1 | 1997 | 长连接、分块传输编码等 |
| HTTP/2.0 | 2015 | 多路复用、头信息压缩等 |

# 12、HTTP 响应
## 响应报文的构成
* 状态行
  * 200 OK：客户端请求成功
  * 301：资源被移到其他 URL
  * 302：临时跳转
  * 400 Bad Request：客户端请求有语法错误，不能被服务器理解
  * 401 Unauthorized：请求未经授权
  * 404：请求的资源不存在
  * 500 Server Internal Error：服务器内部发生了不可预期的错误
  * 502 Bad Gateway
  * 503 Server Unavailable：服务器暂时无法处理请求

* 响应头

* 响应正文

# 13、Socket
通俗地讲，Socket 是程序和操作系统之间用于网络数据收发的接口，能够借助 Socket 来实现 TCP 和 UDP

在我的 Chatroom 个人项目中，使用了 IP 和 PORT 作为参数来构造 Socket 对象，这个构造方法调用了 Socket 的 connect() 方法，而服务器端的 ServerSocket 调用了 accept() 方法，因此是基于 TCP 协议的

# 14、HTTP 请求头
## User-Agent
User-Agent 会告诉网站服务器，访问者是通过什么工具来请求的，如果是爬虫请求，一般会拒绝，如果是用户浏览器，就会应答。

包括系统信息、引擎信息、浏览器版本等信息

## Cookie
类型为“小型文本文件”，是某些网站为了辨别用户身份，进行 Session 跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息

使用 Cookie 时的通信流程：
* 服务器向客户端发送 Cookie
* 浏览器保存 Cookie
* 之后的每次 HTTP 请求浏览器都会将 Cookie 发送给服务器端