- [0、C++中传指针与传引用的比较](#0c中传指针与传引用的比较)
- [1、C 程序从源代码到可执行程序所经历的过程](#1c-程序从源代码到可执行程序所经历的过程)
  - [预处理](#预处理)
  - [编译](#编译)
  - [汇编](#汇编)
  - [链接](#链接)
- [2、C 中 const 和 #define 的区别](#2c-中-const-和-define-的区别)
  - [类型检查](#类型检查)
  - [编译器的处理](#编译器的处理)
  - [在内存中的存储方式](#在内存中的存储方式)
  - [效率](#效率)
- [3、内联函数](#3内联函数)
  - [一些不会被内联的情况](#一些不会被内联的情况)
# 0、C++ 中传指针与传引用的比较
当把引用作为参数传递的过程中，形式参数会作为局部变量在栈中开辟内存空间，存放的是实参变量的地址，对形参的任何操作都会被处理为间接寻址，即通过存放的这个地址去访问主调函数的实参变量。

指针是一个实体，引用只是一个别名。引用不能为空，因此引用在定义时必须初始化，一旦引用一个实体，就不能再引用另一个实体。而指针指向的内容可以为空。

引用是类型安全的，在引用过程中会进行类型检查。而指针则不会。

知乎上“引用不能防止空引用”的论调：
```
void func(A& );
A* a = NULL;
func(*a);     // 空引用，但编译期间无法检查
```

# 1、C 程序从源代码到可执行程序所经历的过程
预处理 -> 编译 -> 汇编 -> 链接

## 预处理
预处理是一种展开，下面是一些常用的预处理命令

 <center>预处理名称</center> | <center>作用</center> | 
:-:|:-|
#define|宏定义|
#undef|取消宏定义|
#include|使另一源文件嵌入到带有 #include 的源文件中|
#if|条件编译语句|
#else|条件编译语句|
#elif|条件编译语句|
#endif|条件编译语句|
#ifdef|条件编译语句|
#ifndef|条件编译语句|
#error|编译程序时，只要遇到 #error 就会生成一个编译错误的提示消息，并停止编译|
#pragma|指示编译器完成一些特定的动作。如 #pragma message 自定义编译信息输出到终端，#pragma once 防止头文件被多次包含，#pragma pack 指定了内存对齐的方式（对 #pragma 指令作用于预处理阶段还是编译阶段存疑）

## 编译
将经过预处理之后的程序转换成特定汇编代码的过程
* 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号
* 语法分析：语法分析器对扫描器产生的记号进行语法分析，产生语法树。语法树是一种以表达式为节点的树。如赋值表达式、加法表达式、乘法表达式、数组表达式和括号表达式组成的复杂表达式。yacc可以实现语法分析，根据用户给定的规则（不同的编程语言对应不同的语法规则）对记号表进行解析
![avatar](markdown-pics/C语法分析.png)
* 语义分析：语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义（相对的，动态语义是在运行期才能确定的语义）。静态语义通常包括：声明和类型的匹配，类型的转换等。语义分析就会对这些方面进行检查，例如将一个 int 型赋值给 int* 型时，语义分析程序会发现这个类型不匹配，编译器就会报错。经过语义分析阶段之后，所有的符号都被标识了类型（如果有些类型需要做隐式转化，语义分析程序会在语法树中插入相应的转换节点）见下图：  
![avatar](markdown-pics/C语义分析.png)
* 优化：
* 目标代码生成：生成一系列的汇编代码
* 目标代码优化：对汇编代码进行优化

## 汇编
将汇编代码转换成机器码，产生目标文件

## 链接
生成可执行代码

# 2、C 中 const 和 #define 的区别
## 类型检查
const 修饰的量有数据类型，编译器会对该量进行类型检查；#define 则只是简单的文本替换，不涉及类型检查，可能产生不可预料的错误

## 编译器的处理
#define 是在预处理的阶段被处理的，而 const 是在编译阶段被处理的

## 在内存中的存储方式
#define 仅仅只是文本替换，有几个地方被使用则替换几次，不涉及内存分配；const 常量会被保存到符号表中，被作为其他变量的值时会相应地分配一次内存
```
#define MACRO 123
const int INF = 100000000;    // 定义常量，编译时未分配内存
int main() {
    int a = MACRO;    // 预处理时进行宏替换，编译时分配内存
    int b = INF;      // 此时为 INF 分配内存
    int c = INF;      // 不分配内存
}
```

## 效率
？

# 3、内联函数
在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。

为了解决这个问题，特别的引入了 inline 修饰符，表示为内联函数。

```
inline function (int i) {
    return i*i;
}
```

使用 inline 修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个调用内联函数地方都换成了函数体的代码，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。

内联函数有点像宏，但是宏是由预处理期进行宏替换，而内联函数是通过编译器来控制的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。

## 一些不会被内联的情况
* 包含了递归、循环
* 通过函数指针调用内联函数
* 构造函数和析构函数
* 内联函数调用了其他函数