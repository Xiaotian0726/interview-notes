- [0、进程状态转换](#0进程状态转换)
- [1、进程间通信（InterProcess Communication）的几种方式](#1进程间通信interprocess-communication的几种方式)
  - [管道](#管道)
  - [计数信号量](#计数信号量)
  - [共享内存](#共享内存)
  - [消息队列](#消息队列)
  - [Socket](#socket)
- [2、同步/异步、阻塞/非阻塞](#2同步异步阻塞非阻塞)
  - [进程阻塞](#进程阻塞)
  - [非阻塞 I/O 系统调用和异步 I/O 系统调用](#非阻塞-io-系统调用和异步-io-系统调用)
  - [总结](#总结)
- [3、CPU 调度算法](#3cpu-调度算法)
  - [FCFS(先来先服务)](#fcfs先来先服务)
  - [SJF(短作业优先)](#sjf短作业优先)
  - [RR(时间片轮转)](#rr时间片轮转)
- [4、死锁](#4死锁)
  - [定义](#定义)
  - [产生原因](#产生原因)
  - [死锁的四个必要条件](#死锁的四个必要条件)
  - [从死锁必要条件的角度来预防死锁](#从死锁必要条件的角度来预防死锁)
  - [银行家算法](#银行家算法)
- [5、虚拟内存](#5虚拟内存)
  - [定义](#定义-1)
  - [虚拟内存实现的理论基础](#虚拟内存实现的理论基础)
  - [页面置换算法](#页面置换算法)
- [6、写时拷贝 copy-on-write](#6写时拷贝-copy-on-write)
- [7、线程安全](#7线程安全)
# 0、进程状态转换
![avatar](./markdown-pics/进程状态转换图.png)

# 1、进程间通信（InterProcess Communication）的几种方式
## 管道
管道是一种半双工的通信信道，数据只能单向流动。实质是一个缓冲区，进程以先进先出的方式从缓冲区存取数据，可将该缓冲区看做一个循环队列

## 计数信号量
它是一个计数器，用于为多个进程提供共享数据对象的访问。其数值相当于当前可使用的资源数目。进程使用P、V操作来使用、释放资源

## 共享内存
允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程读出。效率高，但是需要互斥信号量来保证读写安全

## 消息队列
...

## Socket
是在应用层和传输层之间的一个抽象层，需要与 IP 地址和 Port 绑定

# 2、同步/异步、阻塞/非阻塞
**同步和异步**关注的是消息通信机制

**阻塞和非阻塞**关注的是程序在等待调用结果（消息，返回值）时的状态

## 进程阻塞
进程发起某个系统调用后，由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为 `waiting` 状态，以确保它不会被调度执行，占用 CPU 资源

`阻塞` 这个词是与系统调用紧紧联系在一起的，因为要让一个进程进入 `waiting` 状态，要么是它主动调用 `wait()` 或 `sleep()` 等挂起自己的操作，另一种就是进程发起了某个系统调用，而这个系统调用涉及了 I/O 操作，不能立即完成，于是内核先将该进程置为 `waiting` 状态，调度其他进程的运行，等到它所请求的 I/O 操作完成以后，再将其状态改为 `ready`

大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用接口，这样使得应用级代码的编写更容易（代码的执行顺序和编写顺序是一致的）

## 非阻塞 I/O 系统调用和异步 I/O 系统调用
这两种类型的系统调用会立即返回，不会等待 I/O 操作的完成，应用程序可以继续执行其他的操作，等到 I/O 操作完成以后，操作系统会通知调用进程（设置一个用户空间特殊变量值，或者触发一个 `signal`，或者产生一个软中断，或者调用应用程序的回调函数）

此处非阻塞 I/O 系统调用和异步 I/O 系统调用的区别是：
* 一个非阻塞 I/O 系统调用 `read()`：操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值
* 一个异步 I/O 系统调用 `read()`：结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点

## 总结
* 在进程通信层面，阻塞/非阻塞和同步/异步基本是同义词，但是要注意区分讨论的对象是发送方还是接收方
* 发送方的阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步）是互不影响的
* 在 I/O 系统调用层面，非阻塞 I/O 系统调用和异步 I/O 系统调用存在一定的差别，它们都不会阻塞进程，但是返回结果的方式和内容有所差别

# 3、CPU 调度算法
对于 CPU 调度算法而言，需要同时关注 `周转时间` 和 `响应时间` 两个指标。前台任务需要快速响应用户的请求，更关心响应时间；后台任务则更关心周转时间

## FCFS(先来先服务)
简单，但平均周转时间可能会很长

## SJF(短作业优先)
平均周转时间短，但可能导致长作业的饥饿

## RR(时间片轮转)
响应时间短。如果时间片过短，则上下文切换开销较大；如果时间片过长，则退化成 FCFS

# 4、死锁
## 定义
两个或两个以上的进程在执行过程中，由于竞争资源并等待其他进程释放资源，都无法向前推进的现象

## 产生原因
* 系统资源不足
* 进程推进顺序不合理

## 死锁的四个必要条件
* 互斥 mutex exclusion
* 请求与保持 hold and wait
* 不可剥夺 no preemption
* 循环等待 circular wait
  
## 从死锁必要条件的角度来预防死锁
* 互斥：无法预防
* 请求与保持：一次性分配所有资源，但这样会导致资源利用率低，可能导致饥饿
* 不可剥夺：强行释放进程已经占有的资源
* 循环等待：可以采用有序资源分配法，要求每个进程以编号递增次序

## 银行家算法
是一种避免死锁的算法。把操作系统看作银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款

为保证资金的安全，银行家规定：
* 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客
* 顾客可以分期贷款，但贷款的总数不能超过最大需求量
* 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款
* 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金

对于操作系统而言，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。

如果存在一个由系统所有进程构成的安全序列，则称系统处于安全状态，安全状态一定不会发生死锁。

# 5、虚拟内存
## 定义
具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的存储系统

## 虚拟内存实现的理论基础
程序的局部性原理。进程运行时可以部分装入内存，每一个时间段访问的数据通常只涉及进程空间的一部分。我们只需保证 locality 的内存需求。

## 页面置换算法
* FIFO：存在 FIFO Illustrating Belady’s Anomaly，即分配的页数增加时，缺页率反而上升
* Optimal Page Replacement：理论上的最佳算法，需要面向未来
* LRU：Look into the past, and replace the page that has not been used for the longest time。需要硬件支持来记录时间

# 6、写时拷贝 copy-on-write
操作系统为新生成的子进程/对象创建虚拟空间，但是不分配物理内存，而是共享父进程/对象的物理空间，当父进程或子进程中有更改内存的行为发生时，再为子进程分配物理空间。节约了时间和空间，是对程序性能的优化，可以延迟甚至是避免内存拷贝

# 7、线程安全
`线程安全` 指的不是指线程的安全，而是指内存的安全

在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。内存中的数据可以被多个线程访问和修改（get/set），一般是类/对象的数据，这就是造成问题的潜在原因。在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险