- [0、最长公共子串](#0最长公共子串)
  - [动态规划法](#动态规划法)
- [1、最长公共子序列](#1最长公共子序列)
  - [动态规划法](#动态规划法-1)
- [2、文本串与模式串匹配](#2文本串与模式串匹配)
  - [暴力法](#暴力法)
  - [KMP算法](#kmp算法)
- [3、线性时间找k大算法复杂度证明](#3线性时间找k大算法复杂度证明)
- [4、快速排序算法复杂度证明](#4快速排序算法复杂度证明)
  - [最好情况](#最好情况)
  - [最坏情况](#最坏情况)
# 0、最长公共子串
## 动态规划法
设dp[i][j]为以s1[i]和s2[j]为结尾的公共子串的长度，则：  
(1)s1[i] == s2[j]时，dp[i][j] = dp[i-1][j-1] + 1  
(2)s1[i] != s2[j]时，dp[i][j] = 0  
遍历过程中找到的最大值即为最长公共子串的长度

# 1、最长公共子序列
## 动态规划法
设dp[i][j]为截至s1[i]和s2[j]的最长公共子序列的长度，则：  
(1)s1[i] == s2[j]时，dp[i][j] = dp[i-1][j-1] + 1  
(2)s1[i] != s2[j]时，dp[i][j] = max{dp[i-1][j], dp[i][j-1]}  
遍历过程中找到的最大值即为最长公共子串的

# 2、文本串与模式串匹配
## 暴力法
```
// 暴力匹配算法，s为文本串，p为模式串
// 匹配成功则返回在s中的位置，匹配失败则返回-1
// 时间复杂度O(mn),空间复杂度O(1)
int BFMatch(char* s, char* p) {
    int sLen = strlen(s);
    int pLen = strlen(p);
    if (pLen > sLen) {
        return -1;
    }
    for (int i = 0; i < sLen-pLen+1; i++) {
        bool matchAtThisPos = true;
        for (int j = 0; j < pLen; j++) {
            if (s[i+j] != p[j]) {
                matchAtThisPos = false;
                break;
            }
        }
        if (matchAtThisPos) {
            return i;
        }
    }
    return -1;
}
```
## KMP算法
需要先构造一个数组，数组的长度与模式串长度相等，数组含义是模式串从头截至每个下标的子串，其具有相同前后缀的最大长度。规定首字符的相同前后缀的最大长度为0，即maxLenOfSamePrefixAndSuffix[0] = {0};

KMP算法的时间复杂度为O(m+n)
```
int KMP(char* s, char* p) {
    int sLen = strlen(s);
    int pLen = strlen(p);
    int maxLenOfSamePrefixAndSuffix[pLen] = {0};
    int j = 0, i = 1;
    // 构造辅助数组的过程
    while (i < pLen) {
        if (p[j] == p[i]) {
            maxLenOfSamePrefixAndSuffix[i] = j + 1;
            i++;
            j++;
        } else {
            if (j == 0) {
                maxLenOfSamePrefixAndSuffix[i] = 0;
                i++;
            } else {
                j = maxLenOfSamePrefixAndSuffix[j-1];
            }
        }
    }
    i = j = 0;
    while (i < sLen-pLen+1) {
        if (s[i+j] == p[j]) {
            j++;
            if (j == pLen) {
                return i;
            }
        } else {
            if (j == 0) {
                i++;
            } else {
                i = i + j - maxLenOfSamePrefixAndSuffix[j-1];
                j = maxLenOfSamePrefixAndSuffix[j-1];
            }
        }
    }
    return -1;
}
```

# 3、线性时间找k大算法复杂度证明
设对于$n$个元素的算法复杂度为$T(n)$，则有：

$T(n) \leq T(\frac{4}{5}n) + an$，其中$an$是找较优主元以及$partition$的开销，$a$为常数

$T(\frac{4}{5}n) \leq T((\frac{4}{5}) ^ 2 n) + \frac{4}{5}an$

将$(2)$式代入$(1)$式，得：$T(n) \leq T((\frac{4}{5}) ^ 2 n) + a(n + \frac{4}{5}n)$

$\cdots$

反复代入，可得：$T(n) \leq T((\frac{4}{5}) ^ k n) + a(n + \frac{4}{5}n + (\frac{4}{5})^2n + \cdots + (\frac{4}{5})^kn)$

令$(\frac{4}{5})^kn = 1$，则$T(n) \leq T(1) + a(n + \frac{4}{5}n + (\frac{4}{5})^2n + \cdots + 1)$，对等比数列求和后可得时间复杂度为$O(n)$

# 4、快速排序算法复杂度证明
## 最好情况
$T(n) = 2T(n/2) + an$，$a$是常数，$an$是$partition$的开销

$T(n/2) = 2T(n/4) + a(n/2)$

代入可得$T(n) = 4T(n/4) + a(n + n)$

$\cdots$

反复代入可得$T(n) = 2^kT(1) + kan$，其中$2^k = n$，即$k = \log_2{n}$

故$T(n) = nT(1) + an\log_2{n} = O(nlogn)$

## 最坏情况
$T(n) = T(n-1) + an$，$a$是常数，$an$是$partition$的开销

$T(n-1) = T(n-2) + a(n-1)$

代入可得$T(n) = T(n-2) + a[n + (n-1)]$

$\cdots$

反复代入可得$T(n) = T(1) + a[n + (n-1) + (n-2) + \cdots + 2]$

故$T(n) = O(n^2)$